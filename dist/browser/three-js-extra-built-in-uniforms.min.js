!(function(e, t) {
"object" == typeof exports && "undefined" != typeof module
? (module.exports = t(require("three-full")))
: "function" == typeof define && define.amd
? define(["three-full"], t)
: (e.THREEExtraBuiltInUniforms = t(e.THREE));
})(this, function(e) {
"use strict";
const t = (e = e && e.hasOwnProperty("default") ? e.default : e).REVISION,
a = e.RGBAFormat,
r = e.HalfFloatType,
i = e.FloatType,
n = e.UnsignedByteType,
s = e.TriangleFanDrawMode,
o = (e.riangleStripDrawMode, e.TrianglesDrawMode),
l = e.LinearToneMapping,
u = e.BackSide,
p = e._Math,
d = e.DataTexture,
c = e.Frustum,
m = e.Matrix4,
h = e.ShaderLib,
f = e.UniformsLib,
v = e.Vector3,
g = e.Vector4,
M = e.WebGLAnimation,
b = e.WebGLAttributes,
x = e.WebGLBackground,
L = e.WebGLBufferRenderer,
w = e.WebGLCapabilities,
S = e.WebGLClipping,
A = e.WebGLExtensions,
R = e.WebGLGeometries,
T = e.WebGLIndexedBufferRenderer,
y = e.WebGLInfo,
E = e.WebGLMorphtargets,
_ = e.WebGLObjects,
I = e.WebGLPrograms,
C = e.WebGLProperties,
F = e.WebGLRenderLists,
B = e.WebGLRenderStates,
P = e.WebGLShadowMap,
W = e.WebGLState,
G = e.WebGLTextures,
D = e.WebGLUniforms,
U = e.WebGLUtils,
O = e.WebVRManager,
N = e.WebXRManager,
V = e.UniformsUtils.clone;
var z = function(e) {
console.log("WebGLRenderer", t);
var z =
void 0 !== (e = e || {}).canvas
? e.canvas
: document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
j = void 0 !== e.context ? e.context : null,
k = void 0 !== e.alpha && e.alpha,
Y = void 0 === e.depth || e.depth,
H = void 0 === e.stencil || e.stencil,
X = void 0 !== e.antialias && e.antialias,
q = void 0 === e.premultipliedAlpha || e.premultipliedAlpha,
J = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer,
K = void 0 !== e.powerPreference ? e.powerPreference : "default",
Q = null,
Z = null;
(this.domElement = z),
(this.context = null),
(this.autoClear = !0),
(this.autoClearColor = !0),
(this.autoClearDepth = !0),
(this.autoClearStencil = !0),
(this.sortObjects = !0),
(this.clippingPlanes = []),
(this.localClippingEnabled = !1),
(this.gammaFactor = 2),
(this.gammaInput = !1),
(this.gammaOutput = !1),
(this.physicallyCorrectLights = !1),
(this.toneMapping = l),
(this.toneMappingExposure = 1),
(this.toneMappingWhitePoint = 1),
(this.maxMorphTargets = 8),
(this.maxMorphNormals = 4);
var $,
ee,
te,
ae,
re,
ie,
ne,
se,
oe,
le,
ue,
pe,
de,
ce,
me,
he,
fe,
ve,
ge = this,
Me = !1,
be = null,
xe = null,
Le = null,
we = -1,
Se = {geometry: null, program: null, wireframe: !1},
Ae = null,
Re = null,
Te = new g(),
ye = new g(),
Ee = null,
_e = 0,
Ie = z.width,
Ce = z.height,
Fe = 1,
Be = new g(0, 0, Ie, Ce),
Pe = new g(0, 0, Ie, Ce),
We = !1,
Ge = new c(),
De = new S(),
Ue = !1,
Oe = !1,
Ne = new m(),
Ve = new v();
function ze() {
return null === xe ? Fe : 1;
}
try {
var je = {
alpha: k,
depth: Y,
stencil: H,
antialias: X,
premultipliedAlpha: q,
preserveDrawingBuffer: J,
powerPreference: K
};
if (
(z.addEventListener("webglcontextlost", Xe, !1),
z.addEventListener("webglcontextrestored", qe, !1),
null ===
($ = j || z.getContext("webgl", je) || z.getContext("experimental-webgl", je)))
)
throw null !== z.getContext("webgl")
? new Error("Error creating WebGL context with your selected attributes.")
: new Error("Error creating WebGL context.");
void 0 === $.getShaderPrecisionFormat &&
($.getShaderPrecisionFormat = function() {
return {rangeMin: 1, rangeMax: 1, precision: 1};
});
} catch (e) {
console.error("WebGLRenderer: " + e.message);
}
function ke() {
(ee = new A($)),
(te = new w($, ee, e)).isWebGL2 ||
(ee.get("WEBGL_depth_texture"),
ee.get("OES_texture_float"),
ee.get("OES_texture_half_float"),
ee.get("OES_texture_half_float_linear"),
ee.get("OES_standard_derivatives"),
ee.get("OES_element_index_uint"),
ee.get("ANGLE_instanced_arrays")),
ee.get("OES_texture_float_linear"),
(ve = new U($, ee, te)),
(ae = new W($, ee, ve, te)).scissor(ye.copy(Pe).multiplyScalar(Fe)),
ae.viewport(Te.copy(Be).multiplyScalar(Fe)),
(re = new y($)),
(ie = new C()),
(ne = new G($, ee, ae, ie, te, ve, re)),
(se = new b($)),
(oe = new R($, se, re)),
(le = new _(oe, re)),
(me = new E($)),
(ue = new I(ge, ee, te)),
(pe = new F()),
(de = new B()),
(ce = new x(ge, ae, le, q)),
(he = new L($, ee, re, te)),
(fe = new T($, ee, re, te)),
(re.programs = ue.programs),
(ge.context = $),
(ge.capabilities = te),
(ge.extensions = ee),
(ge.properties = ie),
(ge.renderLists = pe),
(ge.state = ae),
(ge.info = re);
}
ke();
var Ye = null;
"undefined" != typeof navigator &&
(Ye = "xr" in navigator ? new N(ge) : new O(ge)),
(this.vr = Ye);
var He = new P(ge, le, te.maxTextureSize);
function Xe(e) {
e.preventDefault(), console.log("WebGLRenderer: Context Lost."), (Me = !0);
}
function qe() {
console.log("WebGLRenderer: Context Restored."), (Me = !1), ke();
}
function Je(e) {
var t = e.target;
t.removeEventListener("dispose", Je),
(function(e) {
Ke(e), ie.remove(e);
})(t);
}
function Ke(e) {
var t = ie.get(e).program;
(e.program = void 0), void 0 !== t && ue.releaseProgram(t);
}
(this.shadowMap = He),
(this.getContext = function() {
return $;
}),
(this.getContextAttributes = function() {
return $.getContextAttributes();
}),
(this.forceContextLoss = function() {
var e = ee.get("WEBGL_lose_context");
e && e.loseContext();
}),
(this.forceContextRestore = function() {
var e = ee.get("WEBGL_lose_context");
e && e.restoreContext();
}),
(this.getPixelRatio = function() {
return Fe;
}),
(this.setPixelRatio = function(e) {
void 0 !== e && ((Fe = e), this.setSize(Ie, Ce, !1));
}),
(this.getSize = function() {
return {width: Ie, height: Ce};
}),
(this.setSize = function(e, t, a) {
Ye.isPresenting()
? console.warn(
  "WebGLRenderer: Can't change size while VR device is presenting."
  )
: ((Ie = e),
  (Ce = t),
  (z.width = e * Fe),
  (z.height = t * Fe),
  !1 !== a && ((z.style.width = e + "px"), (z.style.height = t + "px")),
  this.setViewport(0, 0, e, t));
}),
(this.getDrawingBufferSize = function() {
return {width: Ie * Fe, height: Ce * Fe};
}),
(this.setDrawingBufferSize = function(e, t, a) {
(Ie = e),
(Ce = t),
(Fe = a),
(z.width = e * a),
(z.height = t * a),
this.setViewport(0, 0, e, t);
}),
(this.getCurrentViewport = function() {
return Te;
}),
(this.setViewport = function(e, t, a, r) {
Be.set(e, Ce - t - r, a, r), ae.viewport(Te.copy(Be).multiplyScalar(Fe));
}),
(this.setScissor = function(e, t, a, r) {
Pe.set(e, Ce - t - r, a, r), ae.scissor(ye.copy(Pe).multiplyScalar(Fe));
}),
(this.setScissorTest = function(e) {
ae.setScissorTest((We = e));
}),
(this.getClearColor = function() {
return ce.getClearColor();
}),
(this.setClearColor = function() {
ce.setClearColor.apply(ce, arguments);
}),
(this.getClearAlpha = function() {
return ce.getClearAlpha();
}),
(this.setClearAlpha = function() {
ce.setClearAlpha.apply(ce, arguments);
}),
(this.clear = function(e, t, a) {
var r = 0;
(void 0 === e || e) && (r |= $.COLOR_BUFFER_BIT),
(void 0 === t || t) && (r |= $.DEPTH_BUFFER_BIT),
(void 0 === a || a) && (r |= $.STENCIL_BUFFER_BIT),
$.clear(r);
}),
(this.clearColor = function() {
this.clear(!0, !1, !1);
}),
(this.clearDepth = function() {
this.clear(!1, !0, !1);
}),
(this.clearStencil = function() {
this.clear(!1, !1, !0);
}),
(this.dispose = function() {
z.removeEventListener("webglcontextlost", Xe, !1),
z.removeEventListener("webglcontextrestored", qe, !1),
pe.dispose(),
de.dispose(),
ie.dispose(),
le.dispose(),
Ye.dispose(),
$e.stop();
}),
(this.renderBufferImmediate = function(e, t) {
ae.initAttributes();
var a = ie.get(e);
e.hasPositions && !a.position && (a.position = $.createBuffer()),
e.hasNormals && !a.normal && (a.normal = $.createBuffer()),
e.hasUvs && !a.uv && (a.uv = $.createBuffer()),
e.hasColors && !a.color && (a.color = $.createBuffer());
var r = t.getAttributes();
e.hasPositions &&
($.bindBuffer($.ARRAY_BUFFER, a.position),
$.bufferData($.ARRAY_BUFFER, e.positionArray, $.DYNAMIC_DRAW),
ae.enableAttribute(r.position),
$.vertexAttribPointer(r.position, 3, $.FLOAT, !1, 0, 0)),
e.hasNormals &&
($.bindBuffer($.ARRAY_BUFFER, a.normal),
$.bufferData($.ARRAY_BUFFER, e.normalArray, $.DYNAMIC_DRAW),
ae.enableAttribute(r.normal),
$.vertexAttribPointer(r.normal, 3, $.FLOAT, !1, 0, 0)),
e.hasUvs &&
($.bindBuffer($.ARRAY_BUFFER, a.uv),
$.bufferData($.ARRAY_BUFFER, e.uvArray, $.DYNAMIC_DRAW),
ae.enableAttribute(r.uv),
$.vertexAttribPointer(r.uv, 2, $.FLOAT, !1, 0, 0)),
e.hasColors &&
($.bindBuffer($.ARRAY_BUFFER, a.color),
$.bufferData($.ARRAY_BUFFER, e.colorArray, $.DYNAMIC_DRAW),
ae.enableAttribute(r.color),
$.vertexAttribPointer(r.color, 3, $.FLOAT, !1, 0, 0)),
ae.disableUnusedAttributes(),
$.drawArrays($.TRIANGLES, 0, e.count),
(e.count = 0);
}),
(this.renderBufferDirect = function(e, t, a, r, i, n) {
var l = i.isMesh && i.normalMatrix.determinant() < 0;
ae.setMaterial(r, l);
var u = rt(e, t, r, i),
p = !1;
(Se.geometry === a.id &&
Se.program === u.id &&
Se.wireframe === (!0 === r.wireframe)) ||
((Se.geometry = a.id),
(Se.program = u.id),
(Se.wireframe = !0 === r.wireframe),
(p = !0)),
i.morphTargetInfluences && (me.update(i, a, r, u), (p = !0));
var d,
c = a.index,
m = a.attributes.position,
h = 1;
!0 === r.wireframe && ((c = oe.getWireframeAttribute(a)), (h = 2));
var f = he;
null !== c && ((d = se.get(c)), (f = fe).setIndex(d)),
p &&
((function(e, t, a) {
if (
a &&
a.isInstancedBufferGeometry & !te.isWebGL2 &&
null === ee.get("ANGLE_instanced_arrays")
)
console.error(
"WebGLRenderer.setupVertexAttributes: using InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
);
else {
ae.initAttributes();
var r = a.attributes,
i = t.getAttributes(),
n = e.defaultAttributeValues;
for (var s in i) {
var o = i[s];
if (o >= 0) {
var l = r[s];
if (void 0 !== l) {
var u = l.normalized,
p = l.itemSize,
d = se.get(l);
if (void 0 === d) continue;
var c = d.buffer,
m = d.type,
h = d.bytesPerElement;
if (l.isInterleavedBufferAttribute) {
var f = l.data,
v = f.stride,
g = l.offset;
f && f.isInstancedInterleavedBuffer
? (ae.enableAttributeAndDivisor(o, f.meshPerAttribute),
  void 0 === a.maxInstancedCount &&
  (a.maxInstancedCount = f.meshPerAttribute * f.count))
: ae.enableAttribute(o),
$.bindBuffer($.ARRAY_BUFFER, c),
$.vertexAttribPointer(o, p, m, u, v * h, g * h);
} else
l.isInstancedBufferAttribute
? (ae.enableAttributeAndDivisor(o, l.meshPerAttribute),
  void 0 === a.maxInstancedCount &&
  (a.maxInstancedCount = l.meshPerAttribute * l.count))
: ae.enableAttribute(o),
$.bindBuffer($.ARRAY_BUFFER, c),
$.vertexAttribPointer(o, p, m, u, 0, 0);
} else if (void 0 !== n) {
var M = n[s];
if (void 0 !== M)
switch (M.length) {
case 2:
$.vertexAttrib2fv(o, M);
break;
case 3:
$.vertexAttrib3fv(o, M);
break;
case 4:
$.vertexAttrib4fv(o, M);
break;
default:
$.vertexAttrib1fv(o, M);
}
}
}
}
ae.disableUnusedAttributes();
}
})(r, u, a),
null !== c && $.bindBuffer($.ELEMENT_ARRAY_BUFFER, d.buffer));
var v = 1 / 0;
null !== c ? (v = c.count) : void 0 !== m && (v = m.count);
var g = a.drawRange.start * h,
M = a.drawRange.count * h,
b = null !== n ? n.start * h : 0,
x = null !== n ? n.count * h : 1 / 0,
L = Math.max(g, b),
w = Math.min(v, g + M, b + x) - 1,
S = Math.max(0, w - L + 1);
if (0 !== S) {
if (i.isMesh)
if (!0 === r.wireframe)
ae.setLineWidth(r.wireframeLinewidth * ze()), f.setMode($.LINES);
else
switch (i.drawMode) {
case o:
f.setMode($.TRIANGLES);
break;
case TriangleStripDrawMode:
f.setMode($.TRIANGLE_STRIP);
break;
case s:
f.setMode($.TRIANGLE_FAN);
}
else if (i.isLine) {
var A = r.linewidth;
void 0 === A && (A = 1),
ae.setLineWidth(A * ze()),
i.isLineSegments
? f.setMode($.LINES)
: i.isLineLoop
? f.setMode($.LINE_LOOP)
: f.setMode($.LINE_STRIP);
} else i.isPoints ? f.setMode($.POINTS) : i.isSprite && f.setMode($.TRIANGLES);
a && a.isInstancedBufferGeometry
? a.maxInstancedCount > 0 && f.renderInstances(a, L, S)
: f.render(L, S);
}
}),
(this.compile = function(e, t) {
(Z = de.get(e, t)).init(),
e.traverse(function(e) {
e.isLight && (Z.pushLight(e), e.castShadow && Z.pushShadow(e));
}),
Z.setupLights(t),
e.traverse(function(t) {
if (t.material)
if (Array.isArray(t.material))
for (var a = 0; a < t.material.length; a++) at(t.material[a], e.fog, t);
else at(t.material, e.fog, t);
});
});
var Qe,
Ze = null,
$e = new M();
function et(e, t, a, r) {
for (var i = 0, n = e.length; i < n; i++) {
var s = e[i],
o = s.object,
l = s.geometry,
u = void 0 === r ? s.material : r,
p = s.group;
if (a.isArrayCamera) {
Re = a;
for (var d = a.cameras, c = 0, m = d.length; c < m; c++) {
var h = d[c];
if (o.layers.test(h.layers)) {
if ("viewport" in h) ae.viewport(Te.copy(h.viewport));
else {
var f = h.bounds,
v = f.x * Ie,
g = f.y * Ce,
M = f.z * Ie,
b = f.w * Ce;
ae.viewport(Te.set(v, g, M, b).multiplyScalar(Fe));
}
Z.setupLights(h), tt(o, t, h, l, u, p);
}
}
} else (Re = null), tt(o, t, a, l, u, p);
}
}
function tt(e, t, a, r, i, n) {
if (
(i &&
i.uniforms &&
(i.uniforms.viewMatrixInverse &&
i.uniforms.viewMatrixInverse.value.copy(a.matrixWorld),
i.uniforms.projectionMatrixInverse &&
i.uniforms.projectionMatrixInverse.value.getInverse(a.projectionMatrix)),
e.onBeforeRender(ge, t, a, r, i, n),
(Z = de.get(t, Re || a)),
e.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse, e.matrixWorld),
e.normalMatrix.getNormalMatrix(e.modelViewMatrix),
e.isImmediateRenderObject)
) {
ae.setMaterial(i);
var s = rt(a, t.fog, i, e);
(Se.geometry = null),
(Se.program = null),
(Se.wireframe = !1),
(function(e, t) {
e.render(function(e) {
ge.renderBufferImmediate(e, t);
});
})(e, s);
} else ge.renderBufferDirect(a, t.fog, r, i, e, n);
e.onAfterRender(ge, t, a, r, i, n), (Z = de.get(t, Re || a));
}
function at(e, t, a) {
var r = ie.get(e),
i = Z.state.lights,
n = Z.state.shadowsArray,
s = r.lightsHash,
o = i.state.hash,
l = ue.getParameters(e, i.state, n, t, De.numPlanes, De.numIntersection, a),
u = ue.getProgramCode(e, l),
p = r.program,
d = !0;
if (void 0 === p) e.addEventListener("dispose", Je);
else if (p.code !== u) Ke(e);
else if (
s.stateID !== o.stateID ||
s.directionalLength !== o.directionalLength ||
s.pointLength !== o.pointLength ||
s.spotLength !== o.spotLength ||
s.rectAreaLength !== o.rectAreaLength ||
s.hemiLength !== o.hemiLength ||
s.shadowsLength !== o.shadowsLength
)
(s.stateID = o.stateID),
(s.directionalLength = o.directionalLength),
(s.pointLength = o.pointLength),
(s.spotLength = o.spotLength),
(s.rectAreaLength = o.rectAreaLength),
(s.hemiLength = o.hemiLength),
(s.shadowsLength = o.shadowsLength),
(d = !1);
else {
if (void 0 !== l.shaderID) return;
d = !1;
}
if (d) {
if (l.shaderID) {
var c = h[l.shaderID];
r.shader = {
name: e.type,
uniforms: V(c.uniforms),
vertexShader: c.vertexShader,
fragmentShader: c.fragmentShader
};
} else
r.shader = {
name: e.type,
uniforms: e.uniforms,
vertexShader: e.vertexShader,
fragmentShader: e.fragmentShader
};
e.onBeforeCompile(r.shader, ge),
(u = ue.getProgramCode(e, l)),
(p = ue.acquireProgram(e, r.shader, l, u)),
(r.program = p),
(e.program = p);
}
var m = p.getAttributes();
if (e.morphTargets) {
e.numSupportedMorphTargets = 0;
for (var f = 0; f < ge.maxMorphTargets; f++)
m["morphTarget" + f] >= 0 && e.numSupportedMorphTargets++;
}
if (e.morphNormals)
for (e.numSupportedMorphNormals = 0, f = 0; f < ge.maxMorphNormals; f++)
m["morphNormal" + f] >= 0 && e.numSupportedMorphNormals++;
var v = r.shader.uniforms;
((e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping) ||
((r.numClippingPlanes = De.numPlanes),
(r.numIntersection = De.numIntersection),
(v.clippingPlanes = De.uniform)),
(r.fog = t),
void 0 === s && (r.lightsHash = s = {}),
(s.stateID = o.stateID),
(s.directionalLength = o.directionalLength),
(s.pointLength = o.pointLength),
(s.spotLength = o.spotLength),
(s.rectAreaLength = o.rectAreaLength),
(s.hemiLength = o.hemiLength),
(s.shadowsLength = o.shadowsLength),
e.lights &&
((v.ambientLightColor.value = i.state.ambient),
(v.directionalLights.value = i.state.directional),
(v.spotLights.value = i.state.spot),
(v.rectAreaLights.value = i.state.rectArea),
(v.pointLights.value = i.state.point),
(v.hemisphereLights.value = i.state.hemi),
(v.directionalShadowMap.value = i.state.directionalShadowMap),
(v.directionalShadowMatrix.value = i.state.directionalShadowMatrix),
(v.spotShadowMap.value = i.state.spotShadowMap),
(v.spotShadowMatrix.value = i.state.spotShadowMatrix),
(v.pointShadowMap.value = i.state.pointShadowMap),
(v.pointShadowMatrix.value = i.state.pointShadowMatrix));
var g = r.program.getUniforms(),
M = D.seqWithValue(g.seq, v);
r.uniformsList = M;
}
function rt(e, t, r, n) {
_e = 0;
var s = ie.get(r),
o = Z.state.lights,
l = s.lightsHash,
c = o.state.hash;
if (Ue && (Oe || e !== Ae)) {
var m = e === Ae && r.id === we;
De.setState(r.clippingPlanes, r.clipIntersection, r.clipShadows, e, s, m);
}
!1 === r.needsUpdate &&
(void 0 === s.program
? (r.needsUpdate = !0)
: r.fog && s.fog !== t
? (r.needsUpdate = !0)
: ((!r.lights ||
  (l.stateID === c.stateID &&
  l.directionalLength === c.directionalLength &&
  l.pointLength === c.pointLength &&
  l.spotLength === c.spotLength &&
  l.rectAreaLength === c.rectAreaLength &&
  l.hemiLength === c.hemiLength &&
  l.shadowsLength === c.shadowsLength)) &&
  (void 0 === s.numClippingPlanes ||
  (s.numClippingPlanes === De.numPlanes &&
  s.numIntersection === De.numIntersection))) ||
  (r.needsUpdate = !0)),
r.needsUpdate && (at(r, t, n), (r.needsUpdate = !1));
var h,
v,
g = !1,
M = !1,
b = !1,
x = s.program,
L = x.getUniforms(),
w = s.shader.uniforms;
if (
(ae.useProgram(x.program) && ((g = !0), (M = !0), (b = !0)),
r.id !== we && ((we = r.id), (M = !0)),
g || Ae !== e)
) {
if (
(L.setValue($, "projectionMatrix", e.projectionMatrix),
te.logarithmicDepthBuffer &&
L.setValue($, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)),
Ae !== e && ((Ae = e), (M = !0), (b = !0)),
r.isShaderMaterial ||
r.isMeshPhongMaterial ||
r.isMeshStandardMaterial ||
r.envMap)
) {
var S = L.map.cameraPosition;
void 0 !== S && S.setValue($, Ve.setFromMatrixPosition(e.matrixWorld));
}
(r.isMeshPhongMaterial ||
r.isMeshLambertMaterial ||
r.isMeshBasicMaterial ||
r.isMeshStandardMaterial ||
r.isShaderMaterial ||
r.skinning) &&
L.setValue($, "viewMatrix", e.matrixWorldInverse);
}
if (r.skinning) {
L.setOptional($, n, "bindMatrix"), L.setOptional($, n, "bindMatrixInverse");
var A = n.skeleton;
if (A) {
var R = A.bones;
if (te.floatVertexTextures) {
if (void 0 === A.boneTexture) {
var T = Math.sqrt(4 * R.length);
(T = p.ceilPowerOfTwo(T)), (T = Math.max(T, 4));
var y = new Float32Array(T * T * 4);
y.set(A.boneMatrices);
var E = new d(y, T, T, a, i);
(E.needsUpdate = !0),
(A.boneMatrices = y),
(A.boneTexture = E),
(A.boneTextureSize = T);
}
L.setValue($, "boneTexture", A.boneTexture),
L.setValue($, "boneTextureSize", A.boneTextureSize);
} else L.setOptional($, A, "boneMatrices");
}
}
return (
M &&
(L.setValue($, "toneMappingExposure", ge.toneMappingExposure),
L.setValue($, "toneMappingWhitePoint", ge.toneMappingWhitePoint),
r.lights &&
((v = b),
((h = w).ambientLightColor.needsUpdate = v),
(h.directionalLights.needsUpdate = v),
(h.pointLights.needsUpdate = v),
(h.spotLights.needsUpdate = v),
(h.rectAreaLights.needsUpdate = v),
(h.hemisphereLights.needsUpdate = v)),
t &&
r.fog &&
(function(e, t) {
(e.fogColor.value = t.color),
t.isFog
? ((e.fogNear.value = t.near), (e.fogFar.value = t.far))
: t.isFogExp2 && (e.fogDensity.value = t.density);
})(w, t),
r.isMeshBasicMaterial
? it(w, r)
: r.isMeshLambertMaterial
? (it(w, r),
  (function(e, t) {
  t.emissiveMap && (e.emissiveMap.value = t.emissiveMap);
  })(w, r))
: r.isMeshPhongMaterial
? (it(w, r),
  r.isMeshToonMaterial
  ? (function(e, t) {
    nt(e, t), t.gradientMap && (e.gradientMap.value = t.gradientMap);
    })(w, r)
  : nt(w, r))
: r.isMeshStandardMaterial
? (it(w, r),
  r.isMeshPhysicalMaterial
  ? (function(e, t) {
    st(e, t),
    (e.reflectivity.value = t.reflectivity),
    (e.clearCoat.value = t.clearCoat),
    (e.clearCoatRoughness.value = t.clearCoatRoughness);
    })(w, r)
  : st(w, r))
: r.isMeshMatcapMaterial
? (it(w, r),
  (function(e, t) {
  t.matcap && (e.matcap.value = t.matcap),
  t.bumpMap &&
  ((e.bumpMap.value = t.bumpMap),
  (e.bumpScale.value = t.bumpScale),
  t.side === u && (e.bumpScale.value *= -1)),
  t.normalMap &&
  ((e.normalMap.value = t.normalMap),
  e.normalScale.value.copy(t.normalScale),
  t.side === u && e.normalScale.value.negate()),
  t.displacementMap &&
  ((e.displacementMap.value = t.displacementMap),
  (e.displacementScale.value = t.displacementScale),
  (e.displacementBias.value = t.displacementBias));
  })(w, r))
: r.isMeshDepthMaterial
? (it(w, r),
  (function(e, t) {
  t.displacementMap &&
  ((e.displacementMap.value = t.displacementMap),
  (e.displacementScale.value = t.displacementScale),
  (e.displacementBias.value = t.displacementBias));
  })(w, r))
: r.isMeshDistanceMaterial
? (it(w, r),
  (function(e, t) {
  t.displacementMap &&
  ((e.displacementMap.value = t.displacementMap),
  (e.displacementScale.value = t.displacementScale),
  (e.displacementBias.value = t.displacementBias)),
  e.referencePosition.value.copy(t.referencePosition),
  (e.nearDistance.value = t.nearDistance),
  (e.farDistance.value = t.farDistance);
  })(w, r))
: r.isMeshNormalMaterial
? (it(w, r),
  (function(e, t) {
  t.bumpMap &&
  ((e.bumpMap.value = t.bumpMap),
  (e.bumpScale.value = t.bumpScale),
  t.side === u && (e.bumpScale.value *= -1)),
  t.normalMap &&
  ((e.normalMap.value = t.normalMap),
  e.normalScale.value.copy(t.normalScale),
  t.side === u && e.normalScale.value.negate()),
  t.displacementMap &&
  ((e.displacementMap.value = t.displacementMap),
  (e.displacementScale.value = t.displacementScale),
  (e.displacementBias.value = t.displacementBias));
  })(w, r))
: r.isLineBasicMaterial
? ((function(e, t) {
  (e.diffuse.value = t.color), (e.opacity.value = t.opacity);
  })(w, r),
  r.isLineDashedMaterial &&
  (function(e, t) {
  (e.dashSize.value = t.dashSize),
  (e.totalSize.value = t.dashSize + t.gapSize),
  (e.scale.value = t.scale);
  })(w, r))
: r.isPointsMaterial
? (function(e, t) {
  (e.diffuse.value = t.color),
  (e.opacity.value = t.opacity),
  (e.size.value = t.size * Fe),
  (e.scale.value = 0.5 * Ce),
  (e.map.value = t.map),
  null !== t.map &&
  (!0 === t.map.matrixAutoUpdate && t.map.updateMatrix(),
  e.uvTransform.value.copy(t.map.matrix));
  })(w, r)
: r.isSpriteMaterial
? (function(e, t) {
  (e.diffuse.value = t.color),
  (e.opacity.value = t.opacity),
  (e.rotation.value = t.rotation),
  (e.map.value = t.map),
  null !== t.map &&
  (!0 === t.map.matrixAutoUpdate && t.map.updateMatrix(),
  e.uvTransform.value.copy(t.map.matrix));
  })(w, r)
: r.isShadowMaterial &&
  ((w.color.value = r.color), (w.opacity.value = r.opacity)),
void 0 !== w.ltc_1 && (w.ltc_1.value = f.LTC_1),
void 0 !== w.ltc_2 && (w.ltc_2.value = f.LTC_2),
D.upload($, s.uniformsList, w, ge)),
r.isShaderMaterial &&
!0 === r.uniformsNeedUpdate &&
(D.upload($, s.uniformsList, w, ge), (r.uniformsNeedUpdate = !1)),
r.isSpriteMaterial && L.setValue($, "center", n.center),
L.setValue($, "modelViewMatrix", n.modelViewMatrix),
L.setValue($, "normalMatrix", n.normalMatrix),
L.setValue($, "modelMatrix", n.matrixWorld),
x
);
}
function it(e, t) {
var a;
(e.opacity.value = t.opacity),
t.color && (e.diffuse.value = t.color),
t.emissive &&
e.emissive.value.copy(t.emissive).multiplyScalar(t.emissiveIntensity),
t.map && (e.map.value = t.map),
t.alphaMap && (e.alphaMap.value = t.alphaMap),
t.specularMap && (e.specularMap.value = t.specularMap),
t.envMap &&
((e.envMap.value = t.envMap),
(e.flipEnvMap.value = t.envMap.isCubeTexture ? -1 : 1),
(e.reflectivity.value = t.reflectivity),
(e.refractionRatio.value = t.refractionRatio),
(e.maxMipLevel.value = ie.get(t.envMap).__maxMipLevel)),
t.lightMap &&
((e.lightMap.value = t.lightMap),
(e.lightMapIntensity.value = t.lightMapIntensity)),
t.aoMap &&
((e.aoMap.value = t.aoMap), (e.aoMapIntensity.value = t.aoMapIntensity)),
t.map
? (a = t.map)
: t.specularMap
? (a = t.specularMap)
: t.displacementMap
? (a = t.displacementMap)
: t.normalMap
? (a = t.normalMap)
: t.bumpMap
? (a = t.bumpMap)
: t.roughnessMap
? (a = t.roughnessMap)
: t.metalnessMap
? (a = t.metalnessMap)
: t.alphaMap
? (a = t.alphaMap)
: t.emissiveMap && (a = t.emissiveMap),
void 0 !== a &&
(a.isWebGLRenderTarget && (a = a.texture),
!0 === a.matrixAutoUpdate && a.updateMatrix(),
e.uvTransform.value.copy(a.matrix));
}
function nt(e, t) {
(e.specular.value = t.specular),
(e.shininess.value = Math.max(t.shininess, 1e-4)),
t.emissiveMap && (e.emissiveMap.value = t.emissiveMap),
t.bumpMap &&
((e.bumpMap.value = t.bumpMap),
(e.bumpScale.value = t.bumpScale),
t.side === u && (e.bumpScale.value *= -1)),
t.normalMap &&
((e.normalMap.value = t.normalMap),
e.normalScale.value.copy(t.normalScale),
t.side === u && e.normalScale.value.negate()),
t.displacementMap &&
((e.displacementMap.value = t.displacementMap),
(e.displacementScale.value = t.displacementScale),
(e.displacementBias.value = t.displacementBias));
}
function st(e, t) {
(e.roughness.value = t.roughness),
(e.metalness.value = t.metalness),
t.roughnessMap && (e.roughnessMap.value = t.roughnessMap),
t.metalnessMap && (e.metalnessMap.value = t.metalnessMap),
t.emissiveMap && (e.emissiveMap.value = t.emissiveMap),
t.bumpMap &&
((e.bumpMap.value = t.bumpMap),
(e.bumpScale.value = t.bumpScale),
t.side === u && (e.bumpScale.value *= -1)),
t.normalMap &&
((e.normalMap.value = t.normalMap),
e.normalScale.value.copy(t.normalScale),
t.side === u && e.normalScale.value.negate()),
t.displacementMap &&
((e.displacementMap.value = t.displacementMap),
(e.displacementScale.value = t.displacementScale),
(e.displacementBias.value = t.displacementBias)),
t.envMap && (e.envMapIntensity.value = t.envMapIntensity);
}
$e.setAnimationLoop(function(e) {
Ye.isPresenting() || (Ze && Ze(e));
}),
"undefined" != typeof window && $e.setContext(window),
(this.setAnimationLoop = function(e) {
(Ze = e), Ye.setAnimationLoop(e), $e.start();
}),
(this.render = function(e, t, a, r) {
if (t && t.isCamera) {
if (!Me) {
(Se.geometry = null),
(Se.program = null),
(Se.wireframe = !1),
(we = -1),
(Ae = null),
!0 === e.autoUpdate && e.updateMatrixWorld(),
null === t.parent && t.updateMatrixWorld(),
Ye.enabled && (t = Ye.getCamera(t)),
(Z = de.get(e, t)).init(),
e.onBeforeRender(ge, e, t, a),
Ne.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
Ge.setFromMatrix(Ne),
(Oe = this.localClippingEnabled),
(Ue = De.init(this.clippingPlanes, Oe, t)),
(Q = pe.get(e, t)).init(),
(function e(t, a, r, i) {
if (!1 !== t.visible) {
var n = t.layers.test(a.layers);
if (n)
if (t.isGroup) r = t.renderOrder;
else if (t.isLight) Z.pushLight(t), t.castShadow && Z.pushShadow(t);
else if (t.isSprite) {
if (!t.frustumCulled || Ge.intersectsSprite(t)) {
i && Ve.setFromMatrixPosition(t.matrixWorld).applyMatrix4(Ne);
var s = le.update(t),
o = t.material;
Q.push(t, s, o, r, Ve.z, null);
}
} else if (t.isImmediateRenderObject)
i && Ve.setFromMatrixPosition(t.matrixWorld).applyMatrix4(Ne),
Q.push(t, null, t.material, r, Ve.z, null);
else if (
(t.isMesh || t.isLine || t.isPoints) &&
(t.isSkinnedMesh && t.skeleton.update(),
!t.frustumCulled || Ge.intersectsObject(t))
) {
i && Ve.setFromMatrixPosition(t.matrixWorld).applyMatrix4(Ne);
var s = le.update(t),
o = t.material;
if (Array.isArray(o))
for (var l = s.groups, u = 0, p = l.length; u < p; u++) {
var d = l[u],
c = o[d.materialIndex];
c && c.visible && Q.push(t, s, c, r, Ve.z, d);
}
else o.visible && Q.push(t, s, o, r, Ve.z, null);
}
for (var m = t.children, u = 0, p = m.length; u < p; u++) e(m[u], a, r, i);
}
})(e, t, 0, ge.sortObjects),
!0 === ge.sortObjects && Q.sort(),
Ue && De.beginShadows();
var i = Z.state.shadowsArray;
He.render(i, e, t),
Z.setupLights(t),
Ue && De.endShadows(),
this.info.autoReset && this.info.reset(),
void 0 === a && (a = null),
this.setRenderTarget(a),
ce.render(Q, e, t, r);
var n = Q.opaque,
s = Q.transparent;
if (e.overrideMaterial) {
var o = e.overrideMaterial;
n.length && et(n, e, t, o), s.length && et(s, e, t, o);
} else n.length && et(n, e, t), s.length && et(s, e, t);
a && (ne.updateRenderTargetMipmap(a), ne.updateMultisampleRenderTarget(a)),
ae.buffers.depth.setTest(!0),
ae.buffers.depth.setMask(!0),
ae.buffers.color.setMask(!0),
ae.setPolygonOffset(!1),
e.onAfterRender(ge, e, t),
Ye.enabled && Ye.submitFrame(),
(Q = null),
(Z = null);
}
} else
console.error("WebGLRenderer.render: camera is not an instance of Camera.");
}),
(this.allocTextureUnit = function() {
var e = _e;
return (
e >= te.maxTextures &&
console.warn(
"WebGLRenderer: Trying to use " +
e +
" texture units while this GPU supports only " +
te.maxTextures
),
(_e += 1),
e
);
}),
(this.setTexture2D =
((Qe = !1),
function(e, t) {
e &&
e.isWebGLRenderTarget &&
(Qe ||
(console.warn(
"WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."
),
(Qe = !0)),
(e = e.texture)),
ne.setTexture2D(e, t);
})),
(this.setTexture3D = function(e, t) {
ne.setTexture3D(e, t);
}),
(this.setTexture = (function() {
var e = !1;
return function(t, a) {
e ||
(console.warn(
"WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."
),
(e = !0)),
ne.setTexture2D(t, a);
};
})()),
(this.setTextureCube = (function() {
var e = !1;
return function(t, a) {
t &&
t.isWebGLRenderTargetCube &&
(e ||
(console.warn(
"WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."
),
(e = !0)),
(t = t.texture)),
(t && t.isCubeTexture) || (Array.isArray(t.image) && 6 === t.image.length)
? ne.setTextureCube(t, a)
: ne.setTextureCubeDynamic(t, a);
};
})()),
(this.setFramebuffer = function(e) {
be = e;
}),
(this.getRenderTarget = function() {
return xe;
}),
(this.setRenderTarget = function(e) {
(xe = e),
e && void 0 === ie.get(e).__webglFramebuffer && ne.setupRenderTarget(e);
var t = be,
a = !1;
if (e) {
var r = ie.get(e).__webglFramebuffer;
e.isWebGLRenderTargetCube
? ((t = r[e.activeCubeFace]), (a = !0))
: (t = e.isWebGLMultisampleRenderTarget
  ? ie.get(e).__webglMultisampledFramebuffer
  : r),
Te.copy(e.viewport),
ye.copy(e.scissor),
(Ee = e.scissorTest);
} else
Te.copy(Be).multiplyScalar(Fe), ye.copy(Pe).multiplyScalar(Fe), (Ee = We);
if (
(Le !== t && ($.bindFramebuffer($.FRAMEBUFFER, t), (Le = t)),
ae.viewport(Te),
ae.scissor(ye),
ae.setScissorTest(Ee),
a)
) {
var i = ie.get(e.texture);
$.framebufferTexture2D(
$.FRAMEBUFFER,
$.COLOR_ATTACHMENT0,
$.TEXTURE_CUBE_MAP_POSITIVE_X + e.activeCubeFace,
i.__webglTexture,
e.activeMipMapLevel
);
}
}),
(this.readRenderTargetPixels = function(e, t, s, o, l, u) {
if (e && e.isWebGLRenderTarget) {
var p = ie.get(e).__webglFramebuffer;
if (p) {
var d = !1;
p !== Le && ($.bindFramebuffer($.FRAMEBUFFER, p), (d = !0));
try {
var c = e.texture,
m = c.format,
h = c.type;
if (
m !== a &&
ve.convert(m) !== $.getParameter($.IMPLEMENTATION_COLOR_READ_FORMAT)
)
return void console.error(
"WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
);
if (
!(
h === n ||
ve.convert(h) === $.getParameter($.IMPLEMENTATION_COLOR_READ_TYPE) ||
(h === i &&
(te.isWebGL2 ||
ee.get("OES_texture_float") ||
ee.get("WEBGL_color_buffer_float"))) ||
(h === r &&
(te.isWebGL2
? ee.get("EXT_color_buffer_float")
: ee.get("EXT_color_buffer_half_float")))
)
)
return void console.error(
"WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
);
$.checkFramebufferStatus($.FRAMEBUFFER) === $.FRAMEBUFFER_COMPLETE
? t >= 0 &&
  t <= e.width - o &&
  s >= 0 &&
  s <= e.height - l &&
  $.readPixels(t, s, o, l, ve.convert(m), ve.convert(h), u)
: console.error(
  "WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."
  );
} finally {
d && $.bindFramebuffer($.FRAMEBUFFER, Le);
}
}
} else
console.error(
"WebGLRenderer.readRenderTargetPixels: renderTarget is not WebGLRenderTarget."
);
}),
(this.copyFramebufferToTexture = function(e, t, a) {
var r = t.image.width,
i = t.image.height,
n = ve.convert(t.format);
this.setTexture2D(t, 0),
$.copyTexImage2D($.TEXTURE_2D, a || 0, n, e.x, e.y, r, i, 0);
}),
(this.copyTextureToTexture = function(e, t, a, r) {
var i = t.image.width,
n = t.image.height,
s = ve.convert(a.format),
o = ve.convert(a.type);
this.setTexture2D(a, 0),
t.isDataTexture
? $.texSubImage2D($.TEXTURE_2D, r || 0, e.x, e.y, i, n, s, o, t.image.data)
: $.texSubImage2D($.TEXTURE_2D, r || 0, e.x, e.y, s, o, t.image);
});
};
if ("101" !== e.REVISION)
throw "This version of three-js-extra-built-in-uniforms package has been made for revision 101 only.";
var j = {
viewMatrixInverse: !0,
projectionMatrixInverse: !0,
originalWebGLRenderer: e.WebGLRenderer
};
return (e.WebGLRenderer = z), j;
});
